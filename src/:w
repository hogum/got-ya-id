//! This module holds items related to data manipulation
//! for the User Object

use crate::apps::user::utils::validate_name;
use crate::diesel_cfg::{config::connect_to_db, schema::users, schema::users::dsl::*};

use serde::{Deserialize, Serialize};
use validator::Validate;
use validator_derive::Validate;

use bcrypt::{hash, verify, DEFAULT_COST};
use chrono::NaiveDateTime;
use diesel::{self, prelude::*};
use log::error;

/// User Object
/// Holds user data
#[derive(Queryable, Debug, Clone, Validate)]
pub struct User {
    id: i32,
    pub username: String,
    pub email: String,
    password: String,
    phone: Option<String>,
    first_name: Option<String>,
    middle_name: Option<String>,
    last_name: Option<String>,
    created_at: NaiveDateTime,
    updated_at: NaiveDateTime,
    is_active: bool,
    is_verified: bool,
}

/// Temporary holds new User data
/// User Record for new User entries
#[derive(Debug, Clone, Validate, Serialize, Deserialize, Insertable)]
#[table_name = "users"]
pub struct NewUser {
    #[validate(
        length(min = 5, message = "Make username at least 5 letters long"),
        custom = "validate_name"
    )]
    pub username: String,
    #[validate(length(min = 6, message = "Insecure password. Give it at least 6 characters"))]
    password: String,
    #[validate(email(message = "Email format not invented yet"))]
    pub email: String,
}

impl NewUser {
    /// Saves a new user record to the db
    ///
    /// # Returns
    /// User
    pub fn save(&mut self) -> Result<User, &'static str> {
        /*let present_user = users
        .filter(email.eq(&self.email))
        .or_filter(username.eq(&self.username))
        .select((email, username))
        .get_results::<Option<String>>(&connect_to_db)
        .unwrap();*/
        let present_user = users
            .filter(email.eq(&self.email))
            .select(email)
            .first::<String>(&connect_to_db());
        println!("{:?}", present_user);
        match hash(&self.password, DEFAULT_COST) {
            Ok(h) => self.password = h,
            Err(e) => {
                error!("{}", &format!("{:?}", e));
                return Err("Failed to hash password");
            }
        };
        Ok(diesel::insert_into(users::table)
            .values(&*self) // diesel::Insertable unimplemented for &mut
            .get_result(&connect_to_db())
            .expect("Error saving user"))
    }
}

/// Implementations for saved user records
/// These methods handle data access and manipulation
impl User {
    /// Checks the received str against the hashed
    /// user password
    ///
    /// # Returns
    ///
    /// bool: True -> Verified, False -> Fail
    fn verify_pass<'a>(&self, pass: &'a str) -> bool {
        verify(pass, &self.password).unwrap()
    }
}
